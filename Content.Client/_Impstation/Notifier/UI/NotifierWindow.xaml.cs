using Content.Client.UserInterface.Controls;
using Content.Shared._Impstation.CCVar;
using Content.Shared._Impstation.Notifier;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Player;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client._Impstation.Notifier.UI;

[GenerateTypedNameReferences]
public sealed partial class NotifierWindow : FancyWindow
{
    [Dependency] private readonly IClientNotifierManager _notifierManager = default!;
    [Dependency] private readonly IConfigurationManager _configManager = default!;
    [Dependency] private readonly ISharedPlayerManager _player = default!;
    [Dependency] private readonly IPrototypeManager _protoManager = default!;

    private string? SavedChangesText;
    private string? UnsavedChangesText;
    public NotifierWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        SaveNotifierSettings.OnPressed += _ =>
        {
            SaveNotifierSettings.Disabled = true;
            _notifierManager.UpdateNotifier(GetSettings());
        };

        _notifierManager.OnServerDataLoaded += UpdateUi;
        if (_notifierManager.HasLoaded)
            UpdateUi();

        var maxLength =  _configManager.GetCVar(ImpCCVars.NotifierFreetextMaxLength);
        var length = Rope.Collapse(NotifierFreetext.TextRope).Length;
        CharacterLimit.Text = Loc.GetString("notifier-window-char-limit", ("length", length), ("maxLength", maxLength));

        NotifierFreetext.Placeholder = new Rope.Leaf(Loc.GetString("notifier-window-freetext-placeholder"));
        NotifierFreetext.OnTextChanged += _ => UnsavedChanges();
        EnableNotifierCheckBox.OnToggled += _ => UnsavedChanges();
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);

        if (disposing)
            _notifierManager.OnServerDataLoaded -= UpdateUi;
    }

    private PlayerNotifierSettings GetSettings()
    {
        var text = Rope.Collapse(NotifierFreetext.TextRope);
        var toggled = EnableNotifierCheckBox.Pressed;

        return new(text, toggled);
    }

    private void UnsavedChanges()
    {
        // Validate freetext length
        var maxLength =  _configManager.GetCVar(ImpCCVars.NotifierFreetextMaxLength);
        var length = Rope.Collapse(NotifierFreetext.TextRope).Length;

        if (length > maxLength)
        {
            SaveNotifierSettings.Disabled = true;
            CharacterLimit.Text = Loc.GetString("notifier-window-exceeded-char-limit", ("length", length), ("maxLength", maxLength));
            CharacterLimit.FontColorOverride = Color.Red;

            return;
        }


        // If everything is valid, enable save button and inform user they need to save.
        CharacterLimit.Text = Loc.GetString("notifier-window-char-limit", ("length", length), ("maxLength", maxLength));
        UnsavedChangesWarning.Text = UnsavedChangesText;
        UnsavedChangesWarning.FontColorOverride = Color.Red;
        SaveNotifierSettings.Disabled = false;
    }

    public void UpdateUi()
    {
        var notifier = _notifierManager.GetNotifier();

        if (UnsavedChangesText == null && SavedChangesText == null)
        {
            SavedChangesText = Loc.GetString("notifier-window-saved-changes");
            UnsavedChangesText = Loc.GetString("notifier-window-unsaved-changes");
        }

        NotifierFreetext.TextRope = new Rope.Leaf(notifier.Freetext);
        EnableNotifierCheckBox.Pressed = notifier.Enabled;


        CharacterLimit.FontColorOverride = null;
        SaveNotifierSettings.Disabled = true;
        UnsavedChangesWarning.Text = SavedChangesText;
        UnsavedChangesWarning.FontColorOverride = null;
    }
}
