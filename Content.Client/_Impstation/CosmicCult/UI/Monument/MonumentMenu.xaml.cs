using System.Numerics;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared._Impstation.Cosmiccult;
using Content.Shared._Impstation.CosmicCult.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client._Impstation.CosmicCult.UI.Monument;
// Content.Client/_Impstation/CosmicCult/UI/Monument/MonumentMenu.xaml.cs
[GenerateTypedNameReferences]
public sealed partial class MonumentMenu : FancyWindow
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IEntityManager _entityManager = default!;

    private readonly SpriteSystem _sprite;

    // All glyph prototypes
    private readonly IEnumerable<GlyphPrototype> _glyphPrototypes;
    // All influence prototypes
    private readonly IEnumerable<InfluencePrototype> _influencePrototypes;

    private readonly ButtonGroup _glyphButtonGroup;

    private ProtoId<GlyphPrototype> _selectedGlyphProtoId = string.Empty;
    private List<ProtoId<InfluencePrototype>> _unlockedInfluenceProtoIds = [];

    public Action? OnUpgradeButtonPressed;
    public Action<ProtoId<GlyphPrototype>>? OnSelectGlyphButtonPressed;
    public Action<ProtoId<InfluencePrototype>>? OnGainButtonPressed;

    public MonumentMenu()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _sprite = _entityManager.System<SpriteSystem>();

        // Set the protos. These do not dynamically update so we can just store them right off the bat.
        // If an admin adds a new one in the middle of the round. Too bad*!
        // * You could probably just do this in UpdateState if that is necessary
        _glyphPrototypes = _prototypeManager.EnumeratePrototypes<GlyphPrototype>();
        _influencePrototypes = _prototypeManager.EnumeratePrototypes<InfluencePrototype>();

        _glyphButtonGroup = new ButtonGroup();

        UpgradeButton.OnPressed += _ => OnUpgradeButtonPressed?.Invoke();
        SelectGlyphButton.OnPressed += _ => OnSelectGlyphButtonPressed?.Invoke(_selectedGlyphProtoId);
    }

    public void UpdateState(MonumentBuiState state)
    {
        _selectedGlyphProtoId = state.SelectedGlyph;
        _unlockedInfluenceProtoIds = state.UnlockedInfluences;

        // TODO: Fix this nonsense!!
        CultProgressBar.BackgroundStyleBoxOverride = new StyleBoxFlat { BackgroundColor = new Color(15, 17, 30) };
        CultProgressBar.ForegroundStyleBoxOverride = new StyleBoxFlat { BackgroundColor = new Color(91, 62, 124) };

        UpgradeButton.StyleClasses.Add("ButtonColorPurpleAndCool");
        UpgradeButton.StyleClasses.Add("ButtonSquare");

        SelectGlyphButton.StyleClasses.Add("ButtonColorPurpleAndCool");
        SelectGlyphButton.StyleClasses.Add("ButtonSquare");
        // End

        UpdateBar(state);
        UpdateEntropy(state);
        UpdateGlyphs();
        UpdateInfluences();
    }

    // Update all the entropy fields
    private void UpdateBar(MonumentBuiState state)
    {
        CultProgressBar.Value = state.PercentageComplete;
        ProgressBarPercentage.Text = Loc.GetString("monument-interface-progress-bar", ("percentage", (100*state.PercentageComplete).ToString("0.00")));
    }

    // Update all the entropy fields
    private void UpdateEntropy(MonumentBuiState state)
    {
        InfusedEntropy.Text = Loc.GetString("monument-interface-entropy-value", ("infused", state.InfusedEntropy.ToString()));
        AvailableEntropy.Text = Loc.GetString("monument-interface-entropy-value", ("infused", state.AvailableEntropy.ToString()));
        EntropyUntilNextStage.Text = Loc.GetString("monument-interface-entropy-value", ("infused", state.EntropyUntilNextStage.ToString()));
        CrewToConvertUntilNextStage.Text = state.CrewToConvertUntilNextStage.ToString();
    }

    // Update all the glyph buttons
    private void UpdateGlyphs()
    {
        GlyphContainer.RemoveAllChildren();

        foreach (var glyph in _glyphPrototypes)
        {
            var boxContainer = new BoxContainer();

            var button = new Button
            {
                HorizontalExpand = true,
                StyleClasses = {StyleBase.ButtonSquare},
                ToolTip = Loc.GetString(glyph.Tooltip),
                Group = _glyphButtonGroup,
                Pressed = glyph.ID == _selectedGlyphProtoId,
            };

            button.OnPressed +=  _ => UpdateSelectedGlyph(glyph.ID);

            var glyphIcon = new TextureRect
            {
                Texture = _sprite.Frame0(glyph.Icon),
                TextureScale = new Vector2(2f, 2f),
                Stretch = TextureRect.StretchMode.KeepCentered,
            };
            boxContainer.AddChild(button);
            button.AddChild(glyphIcon);

            GlyphContainer.AddChild(boxContainer);
        }
    }

    // Update all the influence thingies
    private void UpdateInfluences()
    {
        InfluencesContainer.RemoveAllChildren();

        foreach (var influence in _influencePrototypes)
        {
            var unlocked = _unlockedInfluenceProtoIds.Contains(influence.ID);
            var influenceBox = new InfluenceUIBox(influence, unlocked);
            influenceBox.OnGainButtonPressed += () => OnGainButtonPressed?.Invoke(influence.ID);

            InfluencesContainer.AddChild(influenceBox);
        }
    }

    // This might not be the best way of doing it, but It makes sense...
    private void UpdateSelectedGlyph(ProtoId<GlyphPrototype> glyph)
    {
        _selectedGlyphProtoId = glyph;
    }
}
